# Основные команды

`cat {имя_файла} {file_name}` - выводит содеримое одного или нескольких файлов
> Пример: `cat file1 file2`

`ls` - выводит перечень содержимого какого-либо каталога
	- `ls -l` - получить детализирован­ный список,
	- `ls -a` - показывает все скрытые файлы помимо тех, что видны (файлы, начинающиеся с точек)
	- `ls -la` - выводит все файлы с расширенной информацией списком
	- `ls -F` - отобразить информацию о типах файлов

`cp {имяфайла} {имякопии}` - копирует файлы
	- скопировать file.txt в файл fileCopy.txt -- `cp file.txt fileCopy.txt`
	- скопировать несколько файлов в какой-либо каталог (папку) с названи­ем dir -- `cp file1 ... fileN dir`

`mv {имяфайла} {новоеимя}` - переименовывает файл / перемещает файлы в указанную дир-ю
	- переименовать файл -- `mv file.txt FILE.txt`
	- переместить несколько файлов в другой каталог -- `mv file1 ... fileN dir`

`touch {file_name}` - создание файла в текущей дирректории
> *ВАЖНО:* Если такой файл уже существует, команда touch не изменяет его, но обновляет информацию о времени
> изменения файла, выводимую с помощью команды `ls -l`

`rm {название_файла}` - удаление файла

`echo {Сообщение}` - выводит какое-либо сообщение в консоли
	- `echo {сообщение} > {название_файла}` - записывает какое-либо сообщение в указанный файл

# Перемещение по каталогам

`cd` - переход в другой каталог

- `сd ..` - вернуться в предыдущий каталог
- `cd /` - переход в корневой каталог
- `cd -` - возврат к предыдущей дирректории

`mkdir [dirname]` - создание папки

`rmdir [dirname]` - удаляет дирректорию

> Если каталог `dir` не пуст, эта команда не сработает. Чтобы удалить каталог со всем его содержимым,
> используйте команду `rm -rf dir`

`-r` -- рекурсивное удаление, которое последовательно удаляет все, что находится внутри каталога dir
`-f` -- делает эту операцию принудительной

*Джокерные символы:*

`*` - указывает оболочке на то, что вместо него можно подставить любое количество произвольных символов.
Следующая ко­манда выдаст список файлов в текущем каталоге: `echo *`

`?` - указывает оболочке на то, что необходимо подставить только один произвольный символ. Например -
комбинации b?at будут соответствовать имена boat и brat

# Вспомогательные программы
`grep {word} {file_name}` - выдает строки из файла или входного потока, которые соответству­ют какому-либо выражению

- `$ grep root /etc/passwd` - напечатать строки из файла `/etc/passwd`, которые содержат текст root
- `$ grep root /etc/*` - отыскать все файлы в каталоге /etc, которые содержат слово root

Параметры (параметры указываются в команде после слова `grep`):

`-i` - для соот­ветствий, нечувствительных к регистру символов
`-n` - выводить построчно (выведет номер строки и строку где нашел указанное слово)
`-v` - инвертирует условие поиска, то есть выдает все строки, не отвечающие условию
Ключи можно комбинировать: `grep -n -v Word file.txt`

> Существует также более мощный вариант команды под названием `egrep` (это всего лишь синоним команды `grep -E`).

`less {file_path && name}` - постранично просмотреть большой файл

- `space` - переместиться на след страницу
- `B` - вернуться на страницу назад
- `Q` - выйти из режима чтения файла
- `/word` - отыскать слово word
- `?word` - поиск в обратном направлении
- `N` - продолжить поиск после того как результат будет найдет

> можно отправить стандартный вывод практически из любой команды непосредственно на стандартный вход другой
> команды. Это исключительно полезно, если команда выводит большое количество результатов,которые вам пришлось
> бы просеивать с использованием какой-либо команды вро­де less. Вот пример отправки результатов команды grep
> в команду less --`$ grep ie /usr/share/dict/words | less`

`pwd` - показать текущую дирректорию

`diff file1 file2` - увидеть различия между двумя текстовыми файлами
	- `diff -u` - когда приходится отправлять выходные данные еще куда-либо, поскольку автоматизированные устройства могут лучше справиться с таким форматом.

`file {имя_файла}` - выводит информацию о типе файла (кодировка, битность, тип файла и тд)

`find {filepath}` - ищет файл в определенной дирректории

> Пример: `find folder/coding.exe` (`find folder/*.exe` - сам догадайся)

`locate` - для поиска файлов. Вместо отыскивания файла в реальном времени эта команда осуществляет поиск в
индексе файлов, который система периодически создает. Поиск с помощью команды `locate` происходит *гораздо
быстрее*, чем с помощью `find`, но если искомый файл появился после создания индекса, команда `locate` не
сможет его найти.

`head {file_dir&&name}` - вывод первых 10 строк файла

- `head -5 /etc/passwd` - увидеть 5 первых строк

`tile {file_dir&&name}` - вывод последних 10 строк файла

- `tail +n` - начать вывод, начиная со строки n

`sort {file_name}` - сортировка файлов

- `-n` - выстроить строки в порядке следования чисел
- `-r` - изменяет порядок следования на обратный
- Sample: `sort file.txt` - выведет отсортированное содержимое файла

> Сортировка происходит только в терминале, сам файл не изменяется

# Ввод и вывод с помощью оболочки

`$ command > file` - направить результат команды command в файл

> Оболочка создаст файл file, если его еще нет. Если такой файл существует, то оболочка сначала
> затрет данные в нем

`set -C` - предотвращающение затирания данных (в оболочке bash)

`$ command >> file` - добавить выводимые данные к файлу вместо его перезаписи

`$ ls /fffffffff > f 2> e` - отправить стандартный вывод в файл f, а стандартную ошибку в файл e
(число  2 определяет идентификатор потока, который изменяет оболочка. Значение 1 - стандартный
вывод, а значение 2 - стан­дартная ошибка)

С помощью нотации `>&` можно направить стандартную ошибку туда же, куда осуществляет­ся стандартный
вывод -- `$ ls /fffffffff > f 2>&1`

`$ head < /proc/cpuinfo` - отправить файл на стандартный ввод команды (оператор <)

# Получение списка процессов и управление ими

`ps` - вывести список работающих процессов

- `PID`  — идентификатор процесса (по PID'у можно убивать процессы)
- `TTY`  — оконечное устройство, в котором запущен процесс
- `STAT`  — статус процесса: что он выполняет и где расположеа отведенная для него память
	- S - ждущий процесс
	- R  — работающий 
	> описание всех символов можно найти на странице ps(1) в руководстве

Флаги:

- `x` - показать все процессы, запущенные вами
- `ax` - показать все процессы системы, а не только те, владельцем которых являетесь вы
- `u` - включить детализированную информацию о процессах
- `w` - показать полные названия команд, а не только те, что помещаются в одной строке

Просмотреть информацию о конкретном процессе:

`ps {ключ если надо} {PID}` // `ps u 3729` (sample)
> ps u $$ - просмотреть информацию о текущем процессе оболочки (параметр $$ является переменной оболочки, которая содержит значе­ние PID текущего процесса.)

`$ kill PID` - убить процесс
- `$ kill -STOP PID` - приостановить процесс
- `$ kill -CONT PID` - возобновить процесс
- `$ kill -KILL PID` - не дает процессу шанс прибрать а собой

	> $kill -9 PID == $kill -KILL PID

`jobs` - узнать не висят ли в текущем терминале приостановленные процессы
> Ctrl + Z - отправить сигнал TSTP с по­мощью сочетания клавиш (приостановить процесс)

`fg` - возобновить процесс командой (вы­вести из фона) или 

`bg` - перевести в фон

`&` - помещение процесса в фон

- `$ gunzip file.gz &` - запуск распаковки файла в фоне (процесс будет работат в фоне, а в консоли выведется строка приглашения)

# Режимы файлов и права доступа

`chmod` - удобный инструмент для повышения безопасности ОС и позволяет назначить права доступа к файлам или каталогам
> терминал --> ls -l --> слева от выведенных файлов надписи вроде -rw-rw-r-- == права доступа

- r - read
- w - write
- x - executable (исполнение)
- 1е 3 символа - права доступа root'a
- 2е 3 символа - права доступа группы
- 3и 3 символа - права доступа остальных пользователей

Назначить права доступа на файлы или каталоги chmod'ом можно двумя способами:

- символьные режимы:
	`$ chmod g+r file`
	`$ chmod o+r file`
	`$ chmod go+r file` - добавить права доступа на чтение файла для группы (g) и всех пользователей (o , по первой букве слова other — «остальные»)

	> go-r - удалить эти права доступа

- абсолютные режимы (с помощью цифр):
	`chmod 777 {file_name}` - назначить полный доступ к файлу (установка прав на чтение и запись указанного файла для всех польз-ей)
	`chmod 666 {file_name}` - убрать букву x (исполнение) у всех пользователей (будет -rw-rw-rw-, a не -rwxrwxrwx)
	`chmod 744 {file_name}` - полный доступ для пользователя и только чтение для группы и всех остальных (-rwxr--r--)
	`chmod 640 {file-name}` - -rw-r-----
	`chmod 755 {file-name}` - -rwx-r-xr-x
	`chmod 505 {file-name}` - -r-x---r-x
	`chmod {нужные числа} ` - назначить права для всех файлов какой-то дирректории (вместо названия файла ставить "")

	> Пример: chmod 740 *

`chmod -R 777 *` - изменить права доступа для всех файлов, вклчая дирректории и файлы в этих дирректориях
> `-R` значит рекурсивный обход (если встречает дирректорию, в ней так же изменяет права доступа)

Так же можно вместо звездочки указывать путь до каталога или файла -- `chmod -R 740 /etc/dat/catalogue`

`$ ln -s target linkname` - создать символическую ссылку от цели `target` к имени ссылки `linkname`
- аргумент `linkname` - имя символической ссылки
- аргумент `target` - задает путь к файлу или каталогу, к которому ведет ссылка
флаг `-s` определяет символическую ссылку
    
# Архивирование и сжатие файлов

- `gzip file` - для сжатия
- `gunzip file.gz` - декомпрессия файла <file>.gz и уда­ления суффикса из названия

> команда gzip не создает архивы файлов, то есть она не упаковывает несколько файлов и каталогов в один файл
> Для создания архива используйте команду `tar`:

`$ tar cvf archive.tar file1 file2 ...` || `$ tar -cf archive.tar folder/`
параметры file1, file2 и т.д. являются именами файлов и каталогов, которые нужно упаковать в архив <archive>.tar

`c` - активизирует режим создания

`v` - активизирует подробный диагностический вывод, при котором команда tar отображает имена файлов
    и каталогов в архиве по мере работы  с ними. Если добавить еще один флаг `v` , команда tar
    отобразит такие подробности, как размер файла и права доступа к нему

`f` - обозначает файл-параметр. Следующий после этого флага аргумент в командной строке должен быть именем файла-архива (использовать всегда)

`$ tar xvf archive.tar` - распаковать указанный архив

`x` - переводит команду tar в режим извлечения

`$ tar tvf archive.tar` - просмотреть файл .tar в режиме содержания - проверить целостность архива и посмотреть что внутри

`t` - просмотреть файл .tar в режиме содержания
`p` - сохранить права доступа
`z` - автоматически задействовать команду gzip (как при извлечении, так и при создании архива)

> проверить сжатый архив -- `$ tar ztvf file.tar.gz`

Распаковка .tar.gz:
	Медленный начальный способ:
		$ gunzip file.tar.gz
		$ tar xvf file.tar
	
	Быстрый и продвинутый способ:
		$ zcat file.tar.gz | tar xvf —
		zcat == gunzip -dc:
			-d - отвечает за декомпрессию
			-c - отправляет результат на стандартный вывод (в данном случае команде tar)
	// Файл .tgz — это то же самое, что и файл .tar.gz

Другие утилиты сжатия:
	bzip2 - соз­дает файлы, оканчивающиеся на .bz2
		работает медленнее, но тектовики сжимает лучше чем gzip
	bunzip - декомпрессия файлов .bz2
		// параметры для обоих ком­понентов похожи на параметры команды gzip
		// Для команды tar параметром компрессии/декомпрессии в ре­жиме bzip2 является символ j
	xz - компрессия / unxz - декомпрессия
		// ее аргументы сход­ны с параметрами команды gzip
	zip -r {как будет называться архив} {название папки, которую надо зазиповать} - создает архив .zip c указанной папкой внутри
		Пример: zip -r archive folder/
			// при зиповании в отличии от операции с tar в имени будущего архива НЕ надо указывать расширение файла (.zip)
	unzip {имя_архива} - разархивация .zip архива в текущую папку






========================================================ИЕРАРХИЯ КАТАЛОГОВ LINUX========================================================
Компьютер:
	bin -- содержит исполняемые файлы наиболее важных команд и исполняемые файлы всех остальных команд помещаются по мере убывания вложенности в эту папку; так же данный каталог может содержаться в других каталогах
	dev -- содержит файлы, связанные с устройствами компьютера. Каждое ус-во предтавлено в ней одним или несколькими файлами. Запись и чтение которых означают общение с данным устройством
	еtc -- содержит конфигурационные файлы, относящиеся к системе в целом (grub, mozilla, шрифты, пароль пользователя, файлы загрузки, файлы устройств, сетевые настройки)
	home -- cодержит личные каталоги обычных пользователей
	lib -- cодерит наиболее важные системные библиотеки, остальные библиотеки помещаются по мере убывания вложенности в папки usr/lib && usr/local/lib
	proc -- этот каталог представляет системную статистику в виде интерфейса «каталог-файл». Каталог /proc содержит информацию о запущенных в данный момент процессах, а также о некоторых параметрах ядра.
	sys -- данный каталог подобен каталогу /proc тем, что он предоставляет интер­фейс устройствам и системе
	sbin -- здесь расположены системные исполняемые файлы. Команды из ката­лога /sbin относятся к управлению системой, поэтому у обычных пользовате­лей, как правило, в командном пути не указаны компоненты каталога /sbin .Многие утилиты из этого каталога не будут работать, если вы запустите их не с правами корневого пользователя
	tmp -- хранилище для небольших временных файлов
	boot -- содержит файлы загрузчика ядра (в ней находится загрузчик Grub к примеру)
	opt -- Здесь может находиться дополнительное ПО сторонних разработчиков. Многие версии системы не используют каталог /opt
	media -- содержит папки, создаваемые автоматически монтировщиком, куда подключаются разделы жестких дисков (флеш-накопители, жесткие диски и тд)
	root -- домашняя папка суперпользователя и хранит все его настройки
	usr -- содержит обширную иерархию каталогов, включающую основную часть системы Linux. Разумным будет выделить папку share/doc, в которой содержится документация по программам, которые установлены в системе
	var -- Изменяемый подкаталог, в котором команды хранят информацию во вре­мя исполнения. Системный журнал, отслеживание активности пользователей, кэш, а также другие файлы, которые создаются системными командами, распо­ложены здесь

clear - очистить терминал

Выгрузка команд из текстового файла в терминал для выполнения:
	Допустим есть файл cmd.txt с содержимым 'date; pwd; ls', который был создан посредством команды echo 'date; pwd; ls' > cmd.txt
	sh cmd.txt -- выполнит этот файл

exit - выход из терминала

> {название_файла} - создание файла в текущей дирректории
	// Пример: > file.txt

> {дирректория/название_файла} - создание файла в определенной дирректории
	// Пример: > folder/file2.txt



tac {имя_файла} - выводит содержимое файла в обратном порядке (начиная с последней строки, а не символы в обратном порядке)


Запись кода в файл и компиляция в терминале:
	echo 'int main(){printf("Какой-либо текст скомпилированный в терминале\n");}' > coding.c
	ls -l -- просмотр того, что файл действительно создался
	cat coding.c -- просмотр содержимого файла
	gcc -include stdio.h coding.c -o coding.exe // -include stdio.h - ключи для подключения библиотек
	ls -l -- проверка, что exe файл создался
	./coding.exe - запуск exe файлов

./{имя_файла} - запуск исполняемых файлов через терминал


==================================================================УРОК 3==================================================================
cmp {имя1гофайла} {имя2гофайла} - сравнение двух файлов (сравниение эта команда начинает с первых символов, если они не совпадают, то
	значит файлы уже не совпадают и дальше он проверять не будет)

df - показывает разделы на нашем жестком диске

---------
apt-get - команды для управления программами из терминала (делается с правами администратора)
	sudo apt-get install {programm_name} - устанавливает приложение из терминала
	sudo apt-get update - ищет обновления
	sudo apt-get upgrade - обновляет уже установленные программы
	sudo apt-get remove {programm_name} - удаляет указанную программу



==================================================================УРОК 4==================================================================
Если написал какую-либо команду, требующую sudo, без последнего и терминал требует эти права, не писать заного команду со словом sudo, a просто написать sudo !! и прошлая команда будет выполнена. Пример:
	apt-get install {programm_name}
	"ругань терминала"
	sudo !!
	пойдет выполнение первой команды
	Вывод:
		sudo !! помнит предыдущую команду, которую надо было ввести от имени админа

История запущенных команд сохраняется в файле bash history, для того, чтобы команда там не сохранялась надо просто поставить перед командой пробел:
pwd - запишется в историю
 pwd - не запишется в историю

jot - генерирует рандомный текст (для того, чтобы эта команда работала надо установить из репозитория: sudo apt-get install athena-jot):
	jot {кол-во чисел, которые надо сгенерировать} {с какого числа начать генерировать}
		// Пример: jot 10 1 выведет последовательно числа от 1 до 10
	Вывод: jot это как цикл for
	jot -r {сколько необходимо сгенерировать} {ниний предел} {верхний предел}
		// -r == random
		// Пример: jot -r 5 1 10 - выведет 5 рандомных чисел от 1 до 10

cal - показать календарь

w - показывает кто на данный момент вошел в систему

yes - вызывает зацикливание (yes {строка} - и эта строка будте выводиться пока не нажать ctrl+Z)
	// Так же думаю эту команду можно использовать, чтобы ддосить - yes и команда для ддоса следом

du -h -max - показывает размеры и содержимое файлов
	du -h - показывает размер дирректорий

expr {выражение} - производит вычисления в терминале
	expr 3 - 2 (выведет 1)
	expr 20 / 5 (выведет 4)
	expr 20 \* 3 команда expr не понимает просто знак умножения, поэтому его надо экранировать

look - проверить как правильно пишется слово на английском языке (в linux встроен свой английский словарь)
	look moth - выведет все слова, которые начинаются на moth



=================================================================УРОК 5=================================================================
factor {number} - раскладывает число на множители
	Пример: factor 234
	Вывод: 234: 2 3 3 13

reset - если консоль зависла, то эта команда ее перезагрузит

mtr {site_name}- альтернатива сетевым командам ping и trace route
	Пример: mtr google.com

ping {site_name} - высылает запросы на сайт и получает ответы
	Пример: ping google.com

ps aux - покажет много диагностических данных в удобном виде (PID'ы, RSS, TTY, STAT)

alt/esc + . - вызвать команды, которые вводились пользователем ранее ("." - рядом с русской "ю")

Можно выполнять несколько команд за раз:
	cd {название_дирректории}/ && ls -l - зайти в дирректорию и вывести все ее файлы
	ls -l {название_дирректории}/ - просмотреть все файлы в указанной дирректории не заходя в нее

alias {какое название будет использоваться}={команда} - присвоить указанной команде горячую клавишу на текущий сеанс работы терминала
	Пример: alias _=ls - ls будет вызываться при наборе _

tr {заменяемый символ} {символ которым заменяем} - производит простейшую замену символов во входном потоке
	Пример: echo "lol" | tr 'l' 'W' выведет WoW

	tr позволяет менять регистр слова:
		Пример: echo "DMITRY" | tr '[:upper:]' '[:lower:]'

tree - показывает структуру папок и каталого в древовидной форме (её надо устанавливать)

uname -a - выводит версию ядра используемой копии линукс и разрядность

lsb_release -a - показывает дистрибутив используемой системы и основанных на ней дистрибутивов

wall "{message}" - разошлет на терминалы пользователей указанное сообщение
	Пример: wall "qwer"

date - показывает текущую дату и время

uptime - показвает сколько времени работает система без выклюлчения и перезагрузки

hostname - показвает имя компьютера в сети

shutdown -h - завершает работу и выключает питание

reboot - перезагрузка

gedit {file_name} - открывает указанный файл (не в терминале, а в приложении блокнота)

wc {file_name} - показывает сколько строк, слов и символов содержится в файле
	Пример: wc file.txt



==================================================================УРОК 7==================================================================
												СИСТЕМНЫЙ МОНИТОР (Диспетчер задач) в Linux
ps -e - посмотреть список всех процессов
kill -9 {PID_процесса} - убить процесс
	Sample: kill -9 5202

Если требуется вызвать системый монитор с графическим интерфейсом, то в "найти" пишем "системный монитор"



==================================================================УРОК 8==================================================================
Thunar - файловый менеджер на Xubuntu

pstree - показывает всю файловую структуру всех файлов и каталогов

top - показывает какие процессы на данный момент активны в ОС

sudo apt autoremove - удалит ненужные пакеты из загрузчика, чтобы он не забивался

sudo apt autoclean - очистит кэш приложений 



==================================================================УРОК 9==================================================================

rm -rf {название_каталога} - поскольку rmdir не удаляет каталог если в нем есть файлы, то эта команда это делает, поскольку ключ -rf 
	удаляет все рекурсивно и удаляет всё из всех каталогов в текущем. Использовать осторожно.

arch - выведет архитектуру компьютера

сonvert {файлы, которые надо конвертировать(через пробел)} {целевой файл, который появится}- позволяет конвертировать графические файлы в формат pdf
	Sample: convert picture.tiff image.jpg 0.jpg result.pdf



==================================================================УРОК 10==================================================================
screenfetch - показывает все о ситеме, о ядре, разрешении, версию шела, графическое оформле�ть дополнительно через репозиторийь дополнительно через репозиторий
