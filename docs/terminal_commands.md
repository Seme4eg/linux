# Terminal commands
## basics
`man {command}` - get documentation for {command}

`cat {имя_файла} {file_name}` - выводит содеримое одного или нескольких файлов

`ls` - выводит перечень содержимого какого-либо каталога
- `-l` - получить детализирован­ный список,
- `-a` - показывает все скрытые файлы помимо тех, что видны (файлы, начинающиеся с точек)
- `-F` - отобразить информацию о типах файлов

`cp {имя_файла} {имя_копии} [dir]` - копирует файлы

`mv {имя_файла} {новое_имя} [dir]` - переименовывает файл / перемещает файлы в указанную дир-ю

`touch {file_name} [file_names]` - создание файла в текущей дирректории
`> {file_name}` - создание файла в определенной дирректории
`rm {название_файла}` - удаление файла

`echo {Сообщение}` - выводит какое-либо сообщение в консоли

`clear` - очистить терминал
`exit` - выход из терминала
`reset` - если консоль зависла, то эта команда ее перезагрузит

## dirs commands
`pwd` - показать текущую дирректорию

`cd` - переход в другой каталог
- `..` - вернуться в предыдущий каталог
- `/` - переход в корневой каталог
- `-` - возврат к предыдущей дирректории
- `~` - root dir

`mkdir {dir_name}` - создание папки
`rmdir {имя_дирректории}` - удаляет дирректорию
> Если каталог не пуст:
`-r` -- рекурсивное удаление, которое последовательно удаляет все, что находится внутри каталога dir
`-f` -- делает эту операцию принудительной

## redirecting the output of a command

`$ command > file` - направить результат команды command в файл
`$ command >> file` - добавить выводимые данные к файлу вместо его перезаписи

`set -C` - предотвращающение затирания данных (в оболочке bash)

`$ ls /undefined_dir > f 2> e` - отправить стандартный вывод в файл f, а
стандартную ошибку в файл e (число 2 определяет идентификатор потока,
который изменяет оболочка. Зна­чение 1 - стандартный вывод, а значение
2 - стан­дартная ошибка)

`>&` - направить стандартную ошибку туда же, куда осуществляет­ся стандартный вывод
- `$ ls /fffffffff > f 2>&1`

`$ head < /proc/cpuinfo` - отправить файл на стандартный ввод команды (оператор <)

`$ {some command} | {another command}` - pipe the output from one command to another

## view and manage processes
`top` - view processes real time

`ps` - вывести список работающих процессов
- `PID`  — идентификатор процесса
- `TTY`  — оконечное устройство, в котором запущен процесс
- `STAT`  — статус процесса: что он выполняет и где расположеа отведенная для него память
	- S - ждущий процесс
	- R  — работающий
	> описание всех символов можно найти на странице ps(1) в руководстве

- `x` - показать все процессы, запущенные вами
- `ax` - показать все процессы системы, а не только те, владельцем которых являетесь вы
- `u` - включить детализированную информацию о процессах
- `w` - показать полные названия команд, а не только те, что помещаются в одной строке

`pgrep {command}` - find a PID of a process

Просмотреть информацию о конкретном процессе:

`ps {PID}` (`ps -u 3729`)
> ps u $$ - просмо­треть информацию о текущем процессе оболочки (параметр $$ является переменной оболочки, которая содержит значе­ние PID текущего процесса.)

`$ kill -9 PID` - убить процесс
- `$ kill -STOP PID` - приостановить процесс
- `$ kill -CONT PID` - возобновить процесс
- `$ kill -KILL PID` - не дает процессу шанс прибрать а собой

`killall {process command}` - kill all instances of the process

`jobs` - узнать не висят ли в текущем терминале приостановленные процессы
> Ctrl + Z - отправить сигнал TSTP с по­мощью сочетания клавиш (приостановить процесс)

`fg` - возобновить процесс командой (вы­вести из фона)
`bg` - перевести в фон
`&` - помещение процесса в фон

- `$ gunzip file.gz &` - запуск распаковки файла в фоне

## File permissions and ownership
this topic is well explained [here](https://www.youtube.com/watch?v=wBp0Rb-ZJak) on 1:57:48

`-rw-rw-r--`:

- 1st 3 symbols - root permissions
- 2st 3 symbols - group permissions
- 3st 3 symbols - all other users permissions

### Способы назначения прав
`$ chmod g[roup]o[ther]+r[ead] file` - add 'read' permission for group and other users

> go-r - удалить эти права доступа

7 = 'rwx'
6 = 'rw-'
5 = 'r-x'
4 = 'r--'
0 = '---'

`chmod -R[ecursively] 777 *` - изменить права доступа для всех файлов,
вклчая дирректории и файлы в этих дирректориях (так же можно вместо
звездочки указывать путь до каталога или файла)

`$ ln -s target linkname` - создать символическую ссылку от цели `target` к имени ссылки `linkname`
- аргумент `linkname` - имя символической ссылки
- аргумент `target` - задает путь к файлу или каталогу, к которому ведет ссылка
- `-s` определяет символическую ссылку

## Архивирование и сжатие файлов
### GZIP
- `gzip file` - для сжатия
- `gunzip file.gz` - декомпрессия файла <file>.gz и уда­ления суффикса из названия
> команда gzip не создает архивы файлов, то есть она не упаковывает
> несколько файлов и каталогов в один файл. Для создания архива используйте команду `tar`

### TAR
`$ tar cvf archive.tar file1 file2 ...` || `$ tar -cf archive.tar folder/`
`c` - активизирует режим создания
`v` - активизирует подробный диагностический вывод, при котором
команда tar отображает имена файлов и каталогов в архиве по мере
работы с ними. Если добавить еще один флаг `v` , команда tar отобразит
такие подробности, как размер файла и права доступа к нему
`f` - обозначает файл-параметр. Следующий после этого флага аргумент в
командной строке должен быть именем файла-архива (использовать всегда)

`$ tar xvf archive.tar` - распаковать указанный архив
`x` - переводит команду tar в режим извлечения

`$ tar tvf archive.tar` - просмотреть файл .tar в режиме содержания - проверить целостность архива и посмотреть что внутри
`t` - просмотреть файл .tar в режиме содержания
`p` - сохранить права доступа
`z` - автоматически задействовать команду gzip (как при извлечении, так и при создании архива)
> проверить сжатый архив -- `$ tar ztvf file.tar.gz`

### Распаковка .tar.gz:
Медленный начальный способ:
`$ gunzip file.tar.gz`
`$ tar xvf file.tar`

Быстрый и продвинутый способ:
	$ zcat file.tar.gz | tar xvf —
	zcat == gunzip -dc:
		-d - отвечает за деком­прессию
		-c - отправляет результат на стандартный вывод (в данном случае команде tar)

> Файл .tgz — это то же самое, что и файл .tar.gz

### Другие утилиты сжатия:
bzip2 - соз­дает файлы `.bz2`, работает медленнее, но тектовики сжимает лучше чем gzip
bunzip - декомпрессия файлов `.bz2`
> параметры для обоих ком­понентов похожи на параметры команды gzip
> Для команды tar параметром компрессии/декомпрессии в ре­жиме bzip2 является символ j

xz - компрессия / unxz - декомпрессия (ее аргументы сход­ны с параметрами команды gzip)
`zip -r {name} {folder}` - создает архив .zip c указанной папкой внутри (`zip -r archive folder/`)
`unzip {имя_архива}` - разархивация .zip архива в текущую папку

## Other info
`sh {file_name}` - run any file as bash script (`.txt` as well)

`./{имя_файла}` - запуск исполняемых файлов через терминал

`tac {имя_файла}` - выводит содержимое файла в обратном порядке
(начиная с последней строки, а не символы в обратном порядке)

`df` - показывает разделы на нашем жестком диске

`sudo !!` - run last command but with superuser rights

`sudo su` - change to root account

`s[witch]u[ser] {username}` - change user

История запущенных команд сохраняется в файле bash history, поставь
пробел перед командой, чтобы не сохранять:
`pwd` - запишется в историю
` pwd` - не запишется в историю

`w` - показывает кто на данный момент вошел в систему

`du -h -max` - показывает размеры и содержимое файлов
`du -h` - показывает размер дирректорий

`look {expression}` - output all words starting with `expression`

`factor {number}` - раскладывает число на множители

`mtr {site_url}` - альтернатива сетевым командам ping и trace route
`ping {site_url}` - высылает запросы на сайт и получает ответы

`alt/esc + .` - вызвать команды, которые вводились пользователем ранее ("." - рядом с русской "ю")

`tr {replace_str} {replace_with}` - производит простейшую замену символов во входном потоке
`echo "lol" | tr 'l' 'W'` --> `WoW`
`echo "DMITRY" | tr '[:upper:]' '[:lower:]'` - поменять регистр слова

`tree` - показывает структуру папок и каталого в древовидной форме (её надо устанавливать)

`uname` -a - выводит версию ядра используемой копии линукс и разрядность
`lsb_release` -a - показывает дистрибутив используемой системы и основанных на ней дистрибутивов

`date` - показывает текущую дату и время
`uptime` - показвает сколько времени работает система без выклюлчения и перезагрузки

`hostname` - показвает имя компьютера в сети

`shutdown` -h - завершает работу и выключает питание
`reboot` - перезагрузка

`gedit {file_name}` - открывает указанный файл (не в терминале, а в приложении блокнота)

`wc {file_name}` - показывает сколько строк, слов и символов содержится в файле

`pstree` - показывает всю файловую структуру всех файлов и каталогов

`sudo apt autoremove` - удалит ненужные пакеты из загрузчика, чтобы он не забивался

`sudo apt autoclean` - очистит кэш приложений

`arch` - выведет архитектуру компьютера

`сonvert file1 file2 result_file.md` - позволяет конвертировать графические файлы в формат pdf
	Sample: convert picture.tiff image.jpg 0.jpg result.pdf

`screenfetch` - показывает все о ситеме, о ядре, разрешении, версию
шела, графическое оформле�ть дополнительно через репозиторийь
дополнительно через репозиторий

`less {file_path && name}` - постранично просмотреть большой файл
- `space` - переместиться на след страницу
- `B` - вернуться на страницу назад
- `Q` - выйти из режима чтения файла
- `/word` - отыскать слово word
- `?word` - поиск в обратном направлении
- `N` - продолжить поиск после того как результат будет найдет

`diff file1 file2` - увидеть различия между двумя текстовыми файлами

`cmp {file0} {file1}` - сравнение двух файлов (сравниение эта команда
начинает с первых символов, если они не совпадают, то значит файлы уже
не совпадают и дальше он проверять не будет)

`file {имя_файла}` - выводит информацию о типе файла (кодировка, битность, тип файла и тд)

`locate` - для поиска файлов. Вместо отыскивания файла в реальном
времени эта команда осуществляет поиск в индек­се файлов, который
система периодически создает. Поиск с помощью команды `locate`
происходит **гораздо быстрее**, чем с помощью `find`, но если искомый
файл появился после создания индекса, команда `locate` не сможет его
найти.

`head [number] {path_to_file}` - вывод первых {number} строк файла (default = 10)
`tile [n] {file_dir&&name}` - вывод последних n строк файла (def. - 10)

`sort {file_name}` - output sorted file content (file is not changed)
	- `-n` - выстроить строки в порядке следования чисел
	- `-r` - изменяет порядок следо­вания на обратный

### find
`find {dir} [flag]` - find file

Example: `find . [-maxdepth {number}] -type f [-not] -iname "*.php"` find all files, which ends [not] in .php/PHP (iname stands for Ignore case) in cur. dir.

if u replace 'f' in command above for 'd' it's gonna search for dirs

Searching for files with particular permissions:

`find . -type f -perm 0664` - find files in cur. dir. with permissions 664

`find . -syze +/-1M` - find all files in cur. dir that r more/less than 1M in size

> u also can combine commands searching for name and size at once

### grep
`grep {search_str} {where to look}` - выдает строки из файла или входного потока, которые соответству­ют какому-либо выражению

`-i` - ignore case
`-n` - outputs line number of entry in file
`-v` - инвертирует условие поиска, то есть выдает все строки, не отвечающие условию

`find . -type f -iname "*.php" -exec grep -i -n "function" {} +`

> `-exec` executes next command with the output from the 1st command
> `{} +` syntax ends `-exec` flag

> Существует также более мощный вариант команды под названием `egrep` (сино­ним команды `grep -E`).
